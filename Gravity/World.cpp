#include<Windows.h>
#include "World.h"
#include "Physics.h"
#include <vector>

std::vector<COLORREF> colors = {
        RGB(0x00,0x00,0x00), RGB(0xFF,0xFF,0x00), RGB(0x1C,0xE6,0xFF), RGB(0xFF,0x34,0xFF), RGB(0xFF,0x4A,0x46), RGB(0x00,0x89,0x41), RGB(0x00,0x6F,0xA6), RGB(0xA3,0x00,0x59),
        RGB(0xFF,0xDB,0xE5), RGB(0x7A,0x49,0x00), RGB(0x00,0x00,0xA6), RGB(0x63,0xFF,0xAC), RGB(0xB7,0x97,0x62), RGB(0x00,0x4D,0x43), RGB(0x8F,0xB0,0xFF), RGB(0x99,0x7D,0x87),
        RGB(0x5A,0x00,0x07), RGB(0x80,0x96,0x93), RGB(0xFE,0xFF,0xE6), RGB(0x1B,0x44,0x00), RGB(0x4F,0xC6,0x01), RGB(0x3B,0x5D,0xFF), RGB(0x4A,0x3B,0x53), RGB(0xFF,0x2F,0x80),
        RGB(0x61,0x61,0x5A), RGB(0xBA,0x09,0x00), RGB(0x6B,0x79,0x00), RGB(0x00,0xC2,0xA0), RGB(0xFF,0xAA,0x92), RGB(0xFF,0x90,0xC9), RGB(0xB9,0x03,0xAA), RGB(0xD1,0x61,0x00),
        RGB(0xDD,0xEF,0xFF), RGB(0x00,0x00,0x35), RGB(0x7B,0x4F,0x4B), RGB(0xA1,0xC2,0x99), RGB(0x30,0x00,0x18), RGB(0x0A,0xA6,0xD8), RGB(0x01,0x33,0x49), RGB(0x00,0x84,0x6F),
        RGB(0x37,0x21,0x01), RGB(0xFF,0xB5,0x00), RGB(0xC2,0xFF,0xED), RGB(0xA0,0x79,0xBF), RGB(0xCC,0x07,0x44), RGB(0xC0,0xB9,0xB2), RGB(0xC2,0xFF,0x99), RGB(0x00,0x1E,0x09),
        RGB(0x00,0x48,0x9C), RGB(0x6F,0x00,0x62), RGB(0x0C,0xBD,0x66), RGB(0xEE,0xC3,0xFF), RGB(0x45,0x6D,0x75), RGB(0xB7,0x7B,0x68), RGB(0x7A,0x87,0xA1), RGB(0x78,0x8D,0x66),
        RGB(0x88,0x55,0x78), RGB(0xFA,0xD0,0x9F), RGB(0xFF,0x8A,0x9A), RGB(0xD1,0x57,0xA0), RGB(0xBE,0xC4,0x59), RGB(0x45,0x66,0x48), RGB(0x00,0x86,0xED), RGB(0x88,0x6F,0x4C),

        RGB(0x34,0x36,0x2D), RGB(0xB4,0xA8,0xBD), RGB(0x00,0xA6,0xAA), RGB(0x45,0x2C,0x2C), RGB(0x63,0x63,0x75), RGB(0xA3,0xC8,0xC9), RGB(0xFF,0x91,0x3F), RGB(0x93,0x8A,0x81),
        RGB(0x57,0x53,0x29), RGB(0x00,0xFE,0xCF), RGB(0xB0,0x5B,0x6F), RGB(0x8C,0xD0,0xFF), RGB(0x3B,0x97,0x00), RGB(0x04,0xF7,0x57), RGB(0xC8,0xA1,0xA1), RGB(0x1E,0x6E,0x00),
        RGB(0x79,0x00,0xD7), RGB(0xA7,0x75,0x00), RGB(0x63,0x67,0xA9), RGB(0xA0,0x58,0x37), RGB(0x6B,0x00,0x2C), RGB(0x77,0x26,0x00), RGB(0xD7,0x90,0xFF), RGB(0x9B,0x97,0x00),
        RGB(0x54,0x9E,0x79), RGB(0xFF,0xF6,0x9F), RGB(0x20,0x16,0x25), RGB(0x72,0x41,0x8F), RGB(0xBC,0x23,0xFF), RGB(0x99,0xAD,0xC0), RGB(0x3A,0x24,0x65), RGB(0x92,0x23,0x29),
        RGB(0x5B,0x45,0x34), RGB(0xFD,0xE8,0xDC), RGB(0x40,0x4E,0x55), RGB(0x00,0x89,0xA3), RGB(0xCB,0x7E,0x98), RGB(0xA4,0xE8,0x04), RGB(0x32,0x4E,0x72), RGB(0x6A,0x3A,0x4C),
        RGB(0x83,0xAB,0x58), RGB(0x00,0x1C,0x1E), RGB(0xD1,0xF7,0xCE), RGB(0x00,0x4B,0x28), RGB(0xC8,0xD0,0xF6), RGB(0xA3,0xA4,0x89), RGB(0x80,0x6C,0x66), RGB(0x22,0x28,0x00),
        RGB(0xBF,0x56,0x50), RGB(0xE8,0x30,0x00), RGB(0x66,0x79,0x6D), RGB(0xDA,0x00,0x7C), RGB(0xFF,0x1A,0x59), RGB(0x8A,0xDB,0xB4), RGB(0x1E,0x02,0x00), RGB(0x5B,0x4E,0x51),
        RGB(0xC8,0x95,0xC5), RGB(0x32,0x00,0x33), RGB(0xFF,0x68,0x32), RGB(0x66,0xE1,0xD3), RGB(0xCF,0xCD,0xAC), RGB(0xD0,0xAC,0x94), RGB(0x7E,0xD3,0x79), RGB(0x01,0x2C,0x58)
};

World::World()
{ 
    //uniform distribution of particles
    
    int i = 0;
    auto num_els = colors.size();
    for (auto& particle : m_particles)
    {
        Position p;
        p.x = generateUniformX();
        p.y = generateUniformY();
        particle.SetPosition(p);
        particle.m_pen = CreatePen(PS_SOLID, 2, colors[i%num_els]);
        i++;
    }
}

int World::GetWindowHeight()
{
    return m_windowHeight;
}

int World::GetWindowWidth()
{
    return m_windowWidth;
}

World::~World()
{
}

int World::generateUniformX()
{
    return uniformDistX(pseudoRandomDeviceX);
}

int World::generateUniformY()
{
    return uniformDistY(pseudoRandomDeviceY);
}

int World::draw(HDC hDc)
{
    CalculateStep();
    for (auto& particle : m_particles)
    {
        particle.step();
        particle.draw(hDc);
    }
    return 0;
}

int World::ScaleDown(HDC hDC)
{
    for (auto& particle : m_particles)
    {
        Position p = particle.GetPosition();
        p.x *= 0.5;
        p.y *= 0.5;
        p.z *= 0.5;
        particle.SetPosition(p);
        particle.draw(hDC);
    }
    return 0;
}


// //calculations for advancing one unit of time
int World::CalculateStep()
{
    //calculate forces
    for (auto& particle1 : m_particles)
        for (auto& particle2 : m_particles)
        {
            Force f = Physics::CalculateGravitationalForce(particle1, particle2);
            particle1.addForce(f);
        }
    return 0;
}
